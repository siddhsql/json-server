const express = require('express')
const methodOverride = require('method-override')
const _ = require('lodash')
const lodashId = require('lodash-id')
const low = require('lowdb')
const Memory = require('lowdb/adapters/Memory')
const FileSync = require('lowdb/adapters/FileSync')
const bodyParser = require('../body-parser')
const validateData = require('./validate-data')
const plural = require('./plural')
const nested = require('./nested')
const singular = require('./singular')
const mixins = require('../mixins')
const assert = require('assert').strict
const utils = require('../utils')
const dbExtensions = require('../db-extension-methods')

module.exports = (db, opts) => {
  // Object.assign(target, source) copies the properties from source1 and source2 into the target object. 
  // If a property already exists in the target object, it will be overwritten by the corresponding property from the sources.
  opts = Object.assign({ foreignKeySuffix: 'Id', _isFake: false }, opts)

  if (typeof db === 'string') {
    db = low(new FileSync(db))
  } else if (!_.has(db, '__chain__') || !_.has(db, '__wrapped__')) {
    db = low(new Memory()).setState(db)
  }  

  // Create router
  const router = express.Router()

  // Add middlewares
  router.use(methodOverride())
  router.use(bodyParser)

  validateData(db.getState())

  // Add lodash-id methods to db
  db._.mixin(lodashId)

  // Add specific mixins
  db._.mixin(mixins)
    
  // Expose database
  router.db = db

  // Expose render
  router.render = (req, res) => {
    res.jsonp(res.locals.data)
  }

  // GET /db
  router.get('/db', (req, res) => {
    res.jsonp(db.getState())
  })

  // Handle /:parent/:parentId/:resource
  router.use(nested(opts))

  // Create routes
  db.forEach((value, key) => {
    if (key === '$schema') {
      // ignore $schema
      return
    }

    if (_.isPlainObject(value)) {
      router.use(`/${key}`, singular(db, key, opts))
      return
    }

    if (_.isArray(value)) {
      router.use(`/${key}`, plural(db, key, opts))
      return
    }

    const sourceMessage = ''
    // if (!_.isObject(source)) {
    //   sourceMessage = `in ${source}`
    // }

    const msg =
      `Type of "${key}" (${typeof value}) ${sourceMessage} is not supported. ` +
      `Use objects or arrays of objects.`

    throw new Error(msg)
  }).value()

  /* BEGIN NEW API */

  // add extension methods to db
  _.mixin(db, dbExtensions);

  function isInsertingIntoObject(path) {
    path = utils.Path(path);
    if (path.isRoot()) {
      return false; // to insert into root must give key
    }
    const depth = path.depth();
    assert.ok(depth > 0);
    const path_minus_one = path.truncate(depth - 1);
    const x = db.getElement(path_minus_one);
    return _.isPlainObject(x);
  }

  function isInsertingIntoArrayWithAutoGeneratedId(path) {
    path = utils.Path(path);
    if (path.isRoot()) {
      return true; // since user did not give a key in the path, assume the root is array
    }
    if (db.exists(path)) {
      const depth = path.depth();
      assert.ok(depth > 0);
      const path_minus_one = path.truncate(depth - 1);
      const x = db.getElement(path_minus_one);
      return _.isArray(x);  
    }
    return false;
  }

  function isInsertingIntoArrayWithGivenId(path) {
    path = utils.Path(path);
    if (path.isRoot()) {
      return false;
    }
    const depth = path.depth();
    assert.ok(depth > 0);
    const path_minus_one = path.truncate(depth - 1);
    const x = db.getElement(path_minus_one);
    return _.isArray(x);
  }

  function GET(req, res, next) {
    let depth = req.query.depth;
    let e = db.getElement(req.path);
    if (depth) {
      depth = parseInt(depth);
      if (!Number.isInteger(depth)) {
        throw new Error(`invalid depth ${depth}`);
      }
      if (depth < 0) {
        throw new Error(`invalid depth ${depth}`);
      }
      e = utils.truncate(e, depth);
    }
    res.locals.data = e;
    next();    
  }

  /**
   * This function performs an UPSERT in the database. i.e., create if not exist else update existing record.
   * @param {*} req 
   * @param {*} res 
   * @param {*} next 
   */
  function PUT(req, res, next) {
    if (isInsertingIntoObject(req.path)) {
      db.upsertObject(req.path, req.body); // BodyParser will take care of deserialization for us    
    } else {
      throw new Error("not implemented!");
    }
    res.locals.data = {"status": "ok"} // set to some dummy message
    next();
  }

  function DELETE(req, res, next) {
    if (isInsertingIntoObject(req.path)) {
      db.deleteObject(req.path); // BodyParser will take care of deserialization for us    
    } else {
      throw new Error("not implemented!");
    }
    res.locals.data = {"status": "ok"} // set to some dummy message
    next();
  }

  function reqHandler(req, res, next) {
    // the reason I do it like this instead of using router.get, router.put etc. is explained here:
    // https://stackoverflow.com/questions/76872192/express-js-request-path-changes-from-middleware-to-endpoint
    switch (req.method) {
      case "GET":
        GET(req, res, next);
        break;
      case "PUT":
        PUT(req, res, next);
        break;
      case "DELETE":
        DELETE(req, res, next);
        break;
      default:
        res.status(400);
        res.locals.data = {"status": "bad request"};
        next();
    }
  }

  // https://expressjs.com/en/api.html#path-examples
  // this will only be invoked if the path starts with /$
  // the first backslash escapes the /
  // the second backslash escapes the $
  router.use(/\/\$/, reqHandler);

  /* END NEW API */
  
  router.use((req, res) => {
    if (!res.locals.data) {
      res.status(404);
      res.locals.data = {}
    }

    router.render(req, res)
  })

  // global error handler. see: https://expressjs.com/en/guide/error-handling.html
  // You define error-handling middleware last, after other app.use() and routes calls;
  router.use((err, req, res, next) => {
    if (res.headersSent) {
      // when you add a custom error handler, you must delegate to the default Express
      // error handler, when the headers have already been sent to the client
      return next(err)
    }
    console.error(err.stack)
    res.status(500).send(err.stack)
  })

  return router
}
